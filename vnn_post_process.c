/****************************************************************************
*   Generated by ACUITY 6.30.0
*   Match ovxlib 1.1.83
*
*   Neural Network appliction post-process source file
****************************************************************************/
/*------------------------------------------- 
                Includes
-------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "vsi_nn_pub.h"

#include "vnn_global.h"
#include "vnn_post_process.h"

#define _BASETSD_H

/*------------------------------------------- 
                  Variable definitions
-------------------------------------------*/

/*{graph_output_idx, postprocess}*/
const static vsi_nn_postprocess_map_element_t* postprocess_map = NULL;


/*------------------------------------------- 
                  Functions
-------------------------------------------*/
static void save_output_data(vsi_nn_graph_t *graph)
{
    uint32_t i;
#define _DUMP_FILE_LENGTH 1028
#define _DUMP_SHAPE_LENGTH 128
    char filename[_DUMP_FILE_LENGTH] = {0}, shape[_DUMP_SHAPE_LENGTH] = {0};
    vsi_nn_tensor_t *tensor;

    for(i = 0; i < graph->output.num; i++)
    {
        tensor = vsi_nn_GetTensor(graph, graph->output.tensors[i]);
        vsi_nn_ShapeToString( tensor->attr.size, tensor->attr.dim_num,
            shape, _DUMP_SHAPE_LENGTH, FALSE );
        snprintf(filename, _DUMP_FILE_LENGTH, "output%u_%s.dat", i, shape);
        vsi_nn_SaveTensorToBinary(graph, tensor, filename);

    }
}

static vsi_bool get_top
    (
    float *pfProb,
    float *pfMaxProb,
    vsi_size_t *pMaxClass,
    vsi_size_t outputCount,
    vsi_size_t topNum
    )
{
    vsi_size_t i, j, k;

    #define MAX_TOP_NUM 20
    if (topNum > MAX_TOP_NUM) return FALSE;

    memset(pfMaxProb, 0xfe, sizeof(float) * topNum);
    memset(pMaxClass, 0xff, sizeof(vsi_size_t) * topNum);

    for (j = 0; j < topNum; j++)
    {
        for (i=0; i<outputCount; i++)
        {
            for (k=0; k < topNum; k ++)
            {
                if(i == pMaxClass[k])
                    break;
            }

            if (k != topNum)
                continue;

            if (pfProb[i] > *(pfMaxProb+j))
            {
                *(pfMaxProb+j) = pfProb[i];
                *(pMaxClass+j) = i;
            }
        }
    }

    return TRUE;
}

static vsi_status show_top5
    (
    vsi_nn_graph_t *graph,
    vsi_nn_tensor_t *tensor
    )
{
    vsi_status status = VSI_FAILURE;
    vsi_size_t i,sz,stride;
    float *buffer = NULL;
    uint8_t *tensor_data = NULL;
    vsi_size_t MaxClass[5];
    float fMaxProb[5];
    vsi_size_t topk = 5;

    sz = 1;
    for(i = 0; i < tensor->attr.dim_num; i++)
    {
        sz *= tensor->attr.size[i];
    }

    if(topk > sz)
        topk = sz;

    stride = (vsi_size_t)vsi_nn_TypeGetBytes(tensor->attr.dtype.vx_type);
    if(stride == 0)
    {
        stride = 1;
    }
    tensor_data = (uint8_t *)vsi_nn_ConvertTensorToData(graph, tensor);
    buffer = (float *)malloc(sizeof(float) * sz);

    for(i = 0; i < sz; i++)
    {
        status = vsi_nn_DtypeToFloat32(&tensor_data[stride * i], &buffer[i], &tensor->attr.dtype);
    }

    if (!get_top(buffer, fMaxProb, MaxClass, sz, topk))
    {
        printf("Fail to show result.\n");
        goto final;
    }

    printf(" --- Top%d ---\n", topk);
    for(i = 0; i< topk; i++)
    {
        printf("%3d: %8.6f\n", MaxClass[i], fMaxProb[i]);
    }
    status = VSI_SUCCESS;

final:
    if(tensor_data)vsi_nn_Free(tensor_data);
    if(buffer)free(buffer);
    return status;
}

vsi_status vnn_PostProcessKwsModel(vsi_nn_graph_t *graph)
{
    vsi_status status = VSI_FAILURE;
    vsi_nn_tensor_t *output_tensor = NULL;
    uint8_t *tensor_data = NULL;
    float *prob_buffer = NULL;
    vsi_size_t sz = 1;
    vsi_size_t i, stride;
    
    // Get output tensor (2 classes: unknown, wakeword)
    output_tensor = vsi_nn_GetTensor(graph, graph->output.tensors[0]);
    if (!output_tensor) {
        printf("[KWS PostProcess] Failed to get output tensor\n");
        return VSI_FAILURE;
    }
    
    // Calculate tensor size (expected: 2 for binary classification)
    for (i = 0; i < output_tensor->attr.dim_num; i++) {
        sz *= output_tensor->attr.size[i];
    }
    
    if (sz != 2) {
        printf("[KWS PostProcess] Warning: Expected 2 classes, got %zu\n", sz);
    }
    
    stride = (vsi_size_t)vsi_nn_TypeGetBytes(output_tensor->attr.dtype.vx_type);
    if (stride == 0) stride = 1;
    
    // Convert tensor to raw data
    tensor_data = (uint8_t *)vsi_nn_ConvertTensorToData(graph, output_tensor);
    if (!tensor_data) {
        printf("[KWS PostProcess] Failed to convert tensor data\n");
        return VSI_FAILURE;
    }
    
    prob_buffer = (float *)malloc(sizeof(float) * sz);
    if (!prob_buffer) {
        printf("[KWS PostProcess] Memory allocation failed\n");
        vsi_nn_Free(tensor_data);
        return VSI_FAILURE;
    }
    
    // Dequantization parameters from deployment-metadata.json
    // Output: quantizationScale=0.00390625, quantizationZeroPoint=-128
    const float output_scale = 0.00390625f;
    const int8_t output_zero_point = -128;
    
    // Dequantize int8 output to float probabilities
    // Formula: f = (q - zero_point) * scale
    for (i = 0; i < sz; i++) {
        int8_t quantized_value = ((int8_t *)tensor_data)[i];
        prob_buffer[i] = (quantized_value - output_zero_point) * output_scale;
    }
    
    // Apply softmax to get proper probabilities
    float max_val = prob_buffer[0];
    for (i = 1; i < sz; i++) {
        if (prob_buffer[i] > max_val) max_val = prob_buffer[i];
    }
    
    float sum_exp = 0.0f;
    for (i = 0; i < sz; i++) {
        prob_buffer[i] = expf(prob_buffer[i] - max_val);
        sum_exp += prob_buffer[i];
    }
    
    for (i = 0; i < sz; i++) {
        prob_buffer[i] /= sum_exp;
    }
    
    // Output probabilities (classes from deployment-metadata.json: ["unknown", "wakeword"])
    float unknown_prob = (sz > 0) ? prob_buffer[0] : 0.0f;
    float wakeword_prob = (sz > 1) ? prob_buffer[1] : 0.0f;
    
    // Threshold from deployment-metadata.json: minConfidenceRating = 0.6
    const float confidence_threshold = 0.6f;
    const char *detected_class = (wakeword_prob >= confidence_threshold) ? "wakeword" : "unknown";
    
    // Output JSON format for easy parsing
    printf("{\"unknown_prob\":%.6f, \"wakeword_prob\":%.6f, \"detected_class\":\"%s\", \"confidence\":%.6f}\n",
           unknown_prob, wakeword_prob, detected_class, wakeword_prob);
    fflush(stdout);
    
    // Cleanup
    free(prob_buffer);
    vsi_nn_Free(tensor_data);
    
    return VSI_SUCCESS;
}

const vsi_nn_postprocess_map_element_t * vnn_GetPostProcessMap()
{
    return postprocess_map;
}

uint32_t vnn_GetPostProcessMapCount()
{
    if (postprocess_map == NULL)
       return 0;
    else
        return sizeof(postprocess_map) / sizeof(vsi_nn_postprocess_map_element_t);
}

/****************************************************************************
*   VOICEPRINT POST-PROCESSING
****************************************************************************/
#include "my_struct.h"

#define EMBED_DIM 128

static void post_proc_vp(vsi_nn_graph_t *graph, Voiceprint_feature *result)
{
    vsi_status status = VSI_FAILURE;
    vsi_size_t i,sz,stride, x;
    float *buffer = NULL;
    uint8_t *tensor_data = NULL;
    vsi_nn_tensor_t *tensors[1];
    float embedding_tensor[EMBED_DIM];
    result->feature_num = 0;

    for (int j = 0; j < 1; j++) {
        buffer = NULL;
        tensor_data = NULL;

		tensors[j] = vsi_nn_GetTensor(graph, graph->output.tensors[j]);

        sz = 1;
        for(i = 0; i < tensors[j]->attr.dim_num; i++)
        {
            sz *= tensors[j]->attr.size[i];
        }

        stride = (vsi_size_t)vsi_nn_TypeGetBytes(tensors[j]->attr.dtype.vx_type);
        if(stride == 0)
        {
            stride = 1;
        }
        tensor_data = (uint8_t *)vsi_nn_ConvertTensorToData(graph, tensors[j]);
        buffer = (float *)malloc(sizeof(float) * sz);

        for(i = 0; i < sz; i++)
        {
            status = vsi_nn_DtypeToFloat32(&tensor_data[stride * i], &buffer[i], &tensors[j]->attr.dtype);
        }

        if(j == 0) {
            for (x = 0; x < EMBED_DIM; x++) {
                embedding_tensor[x] = buffer[x];
                result->vals[result->feature_num].value = buffer[x];
                result->feature_num++;
            }
        }

        if(tensor_data)vsi_nn_Free(tensor_data);
        if(buffer)free(buffer);
    }
}

vsi_status vnn_PostProcessVoiceprintUint8(vsi_nn_graph_t *graph, Voiceprint_feature *result)
{
    post_proc_vp(graph, result);
    return VSI_SUCCESS;
}